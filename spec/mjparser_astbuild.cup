

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

    boolean errorDetected;
	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, RETURN, PRINT, READ, NEW, VOID, CONST;
terminal SEMI, COMMA, COLON, DOT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal String STRING;
terminal String BOOL;
terminal EQUAL, PLUSEQUAL, MINUSEQUAL, MULEQUAL, DIVEQUAL, MODEQUAL;
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE;
terminal PLUS, DIV, MINUS, MOD, MUL, INC, DEC;
terminal FOR, FOREACH, CONTINUE, BREAK;
terminal PUBLIC, PROTECTED, PRIVATE;
terminal ABSTRACT, CLASS, EXTENDS;
terminal IF, EQ, NEQ, GT, GTE, LT, LTE, AND, OR;
terminal ELSE;

terminal MAX;
terminal HASH;

non terminal  ConstAssignList ConstAssignList;
nonterminal GlobalConstDeclaration GlobalConstDeclaration;

non terminal Program Program;
non terminal rs.etf.pp1.symboltable.concepts.Obj ProgramName, Designator, DesignatorArrayHelper, PrepareDesignatorForCombined;
non terminal rs.etf.pp1.symboltable.concepts.Obj Type, TypeOrVoid;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodDeclaration, MethodSignature;
non terminal rs.etf.pp1.symboltable.concepts.Obj Parameter, LocalVarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj FunctionCall, ConstGroup;
non terminal rs.etf.pp1.symboltable.concepts.Obj Var, ConstAssign;

non terminal UnloadDesignator UnloadDesignator;

non terminal rs.etf.pp1.symboltable.concepts.Obj AssingOp, Expr, Term, Factor;
non terminal rs.etf.pp1.symboltable.concepts.Struct Condition, ConditionTerm, ConditionFact, OptionalForCondition;

non terminal Mulop Mulop;
nonterminal Addop Addop;
non terminal AddopRight AddopRight;
nonterminal AddopLeft AddopLeft;
nonterminal MulopRight MulopRight;
nonterminal MulopLeft MulopLeft;
non terminal LoadDesignator LoadDesignator;
nonterminal LoadDesignator1 LoadDesignator1;

non terminal MethodDeclarationList MethodDeclarationList;
non terminal MethodStartFunctionParameters MethodStartFunctionParameters;
non terminal FunctionParameters FunctionParameters;
nonterminal ParameterList ParameterList;
non terminal LocalVarDeclarations LocalVarDeclarations;
nonterminal LocalVarList LocalVarList;
non terminal StartOfConstAssign StartOfConstAssign;
nonterminal EndOfConstAssign EndOfConstAssign;

non terminal StatementList StatementList;
nonterminal Statement Statement;
non terminal OptionalElse OptionalElse;
nonterminal ElseKeyword ElseKeyword;
nonterminal OrKeyword OrKeyword;
nonterminal AndKeyword AndKeyword;
nonterminal FinalizeCondition FinalizeCondition;
nonterminal PrepareCondition PrepareCondition;
nonterminal StatementAdr StatementAdr;

non terminal VarDeclarationList VarDeclarationList;
nonterminal VarDeclarationListByType VarDeclarationListByType;
nonterminal VarDeclaration VarDeclaration;
non terminal TypeDeclarationList TypeDeclarationList;
nonterminal TypeDelcaration TypeDelcaration;
nonterminal DeclarationType DeclarationType;
non terminal VarList VarList;
non terminal AccessModifier AccessModifier;
nonterminal OptionalExtends OptionalExtends;
nonterminal OptionalAbstract OptionalAbstract;

non terminal ClassDeclaration ClassDeclaration;
nonterminal ClassBody ClassBody;

non terminal DesignatorStatement DesignatorStatement;
nonterminal Negative Negative;
non terminal AddopTermList AddopTermList;
nonterminal MulopTermList MulopTermList;
non terminal EndExprStack EndExprStack;
nonterminal EndTermStack EndTermStack;

non terminal GlobalDeclarationList GlobalDeclarationList;
nonterminal GlobalDeclaration GlobalDeclaration;
nonterminal GlobalVarDeclaration GlobalVarDeclaration;
nonterminal GlobalClassDeclaration GlobalClassDeclaration;

non terminal ActPars ActPars;
nonterminal ActParsStart ActParsStart;
nonterminal ActParsList ActParsList;
nonterminal ActPar ActPar;
non terminal Relop Relop;


non terminal rs.etf.pp1.symboltable.concepts.Obj ForeachIterator, ForeachHiddenIterator, ForeachArrayDesignator;
non terminal ForeachBegin ForeachBegin;
nonterminal ForeachStart ForeachStart;
nonterminal ForeachEnd ForeachEnd;
nonterminal ForeachExit ForeachExit;
nonterminal ColonKeyword ColonKeyword;

non terminal OptionalForDesignatorStatement OptionalForDesignatorStatement;
non terminal ForStart ForStart;
nonterminal ForEnd ForEnd;
nonterminal ForExit ForExit;
nonterminal ForRepeatCondition ForRepeatCondition;
nonterminal ForStatements ForStatements;
nonterminal JumpToDesignatorStatement2 JumpToDesignatorStatement2;
nonterminal JumpToEnd JumpToEnd;
nonterminal DesignatorJumpBack DesignatorJumpBack;
nonterminal JumpToStatements JumpToStatements;

non terminal SemiCrazyIdea SemiCrazyIdea;

non terminal LocalVarDeclListing LocalVarDeclListing;
nonterminal LocalvarListing LocalvarListing;

precedence left ELSE;


Program ::= (Program) PROG ProgramName:P1 GlobalDeclarationList:G2 LBRACE MethodDeclarationList:M3 RBRACE {: RESULT=new Program(P1, G2, M3); RESULT.setLine(P1left); :};
ProgramName ::= (ProgramName) STRING:programName {: RESULT=new ProgramName(programName); RESULT.setLine(programNameleft); :};

GlobalDeclarationList ::= (GlobalDeclarationListing) GlobalDeclarationList:G1 GlobalDeclaration:G2 {: RESULT=new GlobalDeclarationListing(G1, G2); RESULT.setLine(G1left); :}
                          |
                          (GlobalDeclarationListEmpty) {: RESULT=new GlobalDeclarationListEmpty(); :} /* Epsilon */
                          ;

GlobalDeclaration ::= (GlobalDeclartionVars) TypeDeclarationList:T1 {: RESULT=new GlobalDeclartionVars(T1); RESULT.setLine(T1left); :}
                    | (GlobalDeclartionClasses) GlobalClassDeclaration:G1 {: RESULT=new GlobalDeclartionClasses(G1); RESULT.setLine(G1left); :}
                    | (GlovalDeclarationConst) GlobalConstDeclaration:G1 {: RESULT=new GlovalDeclarationConst(G1); RESULT.setLine(G1left); :}
                    ;

GlobalClassDeclaration ::= (GlobalClassDeclaration) AccessModifier:A1 OptionalAbstract:O2 CLASS STRING:S3 OptionalExtends:O4 LBRACE ClassBody:C5 RBRACE {: RESULT=new GlobalClassDeclaration(A1, O2, S3, O4, C5); RESULT.setLine(A1left); :};

GlobalConstDeclaration ::= (GlobalConstDeclaration) StartOfConstAssign:S1 Type:T2 ConstAssignList:C3 EndOfConstAssign:E4 SEMI {: RESULT=new GlobalConstDeclaration(S1, T2, C3, E4); RESULT.setLine(S1left); :};
StartOfConstAssign ::= (StartOfConstAssign) CONST {: RESULT=new StartOfConstAssign(); :};
EndOfConstAssign ::= (EndOfConstAssign) {: RESULT=new EndOfConstAssign(); :} /* Epsilon */;
ConstAssignList ::= (ConstAssignListing) ConstAssignList:C1 COMMA ConstAssign:C2 {: RESULT=new ConstAssignListing(C1, C2); RESULT.setLine(C1left); :}
                    |
                    (ConstAssignSingle) ConstAssign:C1 {: RESULT=new ConstAssignSingle(C1); RESULT.setLine(C1left); :}
                    ;

ConstAssign ::= (ConstVarAssing) STRING:name EQUAL ConstGroup:C1 {: RESULT=new ConstVarAssing(name, C1); RESULT.setLine(nameleft); :};
ConstGroup ::= (ConstBool) BOOL:B1 {: RESULT=new ConstBool(B1); RESULT.setLine(B1left); :} | (ConstNumber) NUMBER:N1 {: RESULT=new ConstNumber(N1); RESULT.setLine(N1left); :} | (ConstChar) CHAR:C1 {: RESULT=new ConstChar(C1); RESULT.setLine(C1left); :};

TypeDeclarationList ::= (TypeVarDeclaration) Type:T1 VarList:V2 SEMI {: RESULT=new TypeVarDeclaration(T1, V2); RESULT.setLine(T1left); :};

VarList ::= (VarListing) VarList:V1 COMMA Var:V2 {: RESULT=new VarListing(V1, V2); RESULT.setLine(V1left); :}
            |
            (VarListSingle) Var:V1 {: RESULT=new VarListSingle(V1); RESULT.setLine(V1left); :}
            ;
Var::= (VarArray) STRING:S1 LSQUARE RSQUARE {: RESULT=new VarArray(S1); RESULT.setLine(S1left); :} | (VarSingle) STRING:S1 {: RESULT=new VarSingle(S1); RESULT.setLine(S1left); :};


AccessModifier ::= (AccessPublic) PUBLIC {: RESULT=new AccessPublic(); :} | (AccessProtected) PROTECTED {: RESULT=new AccessProtected(); :} | (AccessPrivate) PRIVATE {: RESULT=new AccessPrivate(); :} | (AccessPackage) {: RESULT=new AccessPackage(); :} /* Epsilon */;
OptionalAbstract ::= (AbstractTrue) ABSTRACT {: RESULT=new AbstractTrue(); :} | (AbstractFalse) {: RESULT=new AbstractFalse(); :} /* Epsilon */;
OptionalExtends ::= (ExtendsTrue) EXTENDS STRING:ClassName {: RESULT=new ExtendsTrue(ClassName); RESULT.setLine(ClassNameleft); :} | (ExtendsFalse) {: RESULT=new ExtendsFalse(); :}  /* Epsilon */;
TypeOrVoid ::= (TypeStringAny) Type:T1 {: RESULT=new TypeStringAny(T1); RESULT.setLine(T1left); :} | (TypeVoid) VOID:typeVoid {: RESULT=new TypeVoid(); :};
Type ::= (TypeString) STRING:typeName {: RESULT=new TypeString(typeName); RESULT.setLine(typeNameleft); :};



MethodDeclarationList ::= (MethodDeclarationListing) MethodDeclarationList:M1 MethodDeclaration:M2 {: RESULT=new MethodDeclarationListing(M1, M2); RESULT.setLine(M1left); :} | (MethodDeclarationListEmpty) {: RESULT=new MethodDeclarationListEmpty(); :} /* Epsilon */;

MethodDeclaration ::= (MethodDeclaration) MethodSignature:M1 LocalVarDeclarations:L2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclaration(M1, L2, S3); RESULT.setLine(M1left); :};
MethodSignature ::= (MethodSignature) TypeOrVoid:returnType STRING:methodName MethodStartFunctionParameters:M1 LPAREN FunctionParameters:F2 RPAREN {: RESULT=new MethodSignature(returnType, methodName, M1, F2); RESULT.setLine(returnTypeleft); :};

MethodStartFunctionParameters ::= (MethodStartFunctionParameters) {: RESULT=new MethodStartFunctionParameters(); :} /* Epsilon */;

FunctionParameters ::= (FunctionParametersList) ParameterList:P1 {: RESULT=new FunctionParametersList(P1); RESULT.setLine(P1left); :} | (FunctionParametersEmpty) {: RESULT=new FunctionParametersEmpty(); :} /* Epsilon */;
ParameterList ::= (ParameterListing) ParameterList:P1 COMMA Parameter:P2 {: RESULT=new ParameterListing(P1, P2); RESULT.setLine(P1left); :} | (ParameterDecl) Parameter:P1 {: RESULT=new ParameterDecl(P1); RESULT.setLine(P1left); :};
Parameter ::= (ParameterSingle) Type:T1 STRING:psingle {: RESULT=new ParameterSingle(T1, psingle); RESULT.setLine(T1left); :}
            |
            (ParameterArr) Type:T1 STRING:parr LSQUARE RSQUARE {: RESULT=new ParameterArr(T1, parr); RESULT.setLine(T1left); :}
            |
            error:l
             {: parser.report_error("Formalni parametar: Izvrsen oporavak do ',' ili kraja " + lleft, null); :} {: RESULT=new ParameterDerived1(); :}
            ;

LocalVarDeclarations ::= (LocalVarDeclList) LocalVarList:L1 {: RESULT=new LocalVarDeclList(L1); RESULT.setLine(L1left); :} | (LocalVarDeclEmpty) {: RESULT=new LocalVarDeclEmpty(); :}  /* Epsilon */;
LocalVarList ::= (LocalVarListList) LocalVarList:L1 LocalvarListing:L2 {: RESULT=new LocalVarListList(L1, L2); RESULT.setLine(L1left); :} | (LocalVarSingle) LocalvarListing:L1 {: RESULT=new LocalVarSingle(L1); RESULT.setLine(L1left); :} ;
LocalvarListing ::= (LocalVarListingList) Type:T1 LocalVarDeclListing:L2 SEMI {: RESULT=new LocalVarListingList(T1, L2); RESULT.setLine(T1left); :} ;
LocalVarDeclListing ::= (LocalVarDeclListingList) LocalVarDeclListing:L1 COMMA LocalVarDecl:L2 {: RESULT=new LocalVarDeclListingList(L1, L2); RESULT.setLine(L1left); :} | (LocalVarDeclListingSingle) LocalVarDecl:L1 {: RESULT=new LocalVarDeclListingSingle(L1); RESULT.setLine(L1left); :};
LocalVarDecl ::=(LocalVarDeclSinge) STRING:Var {: RESULT=new LocalVarDeclSinge(Var); RESULT.setLine(Varleft); :}
                |
                (LocalVarDeclArray) STRING:Var LSQUARE RSQUARE {: RESULT=new LocalVarDeclArray(Var); RESULT.setLine(Varleft); :}
                |
                error SEMI:l
                {: parser.report_error("Lokalna promenljiva: Izvrsen oporavak do ; " + lleft, null); :} {: RESULT=new LocalVarDeclDerived1(); :}
                ;
// todo: untested
//LocalVarDeclarations ::= (LocalVarDeclList) LocalVarList | (LocalVarDeclEmpty)  /* Epsilon */;
//LocalVarList ::= (LocalVarListList) LocalVarList LocalvarListing | (LocalVarSingle) LocalvarListing ;
//LocalvarListing ::= (LocalVarListingList) Type LocalVarDeclListing SEMI ;
//LocalVarDeclListing ::= (LocalVarDeclListingList) LocalVarDeclListing COMMA LocalVarDecl | (LocalVarDeclListingSingle) LocalVarDecl;
//LocalVarDecl ::=(LocalVarDeclSinge) STRING:Var
//                |
//                (LocalVarDeclArray) STRING:Var LSQUARE RSQUARE
//                |
//                error SEMI:l
//                {: parser.report_error("Lokalna promenljiva: Izvrsen oporavak do ; " + lleft, null); :}
//                ;

// TODO: Class Body, errors
ClassBody ::= (ClassBodyStatements) STRING:S1 {: RESULT=new ClassBodyStatements(S1); RESULT.setLine(S1left); :} | (ClassBodyEmpty) {: RESULT=new ClassBodyEmpty(); :} /* Epsilon */;


StatementList ::= (StatementListing) StatementList:S1 Statement:S2 {: RESULT=new StatementListing(S1, S2); RESULT.setLine(S1left); :} | (StatementEmpty) {: RESULT=new StatementEmpty(); :} /* Epsilon */;

Statement ::= (StatementDesignatorStatement) DesignatorStatement:D1 SemiCrazyIdea:S2 {: RESULT=new StatementDesignatorStatement(D1, S2); RESULT.setLine(D1left); :}
            |
            (StatementRead) READ LPAREN Designator:D1 RPAREN SemiCrazyIdea:S2 {: RESULT=new StatementRead(D1, S2); RESULT.setLine(D1left); :}
            |
            (StatementPrintExpr) PRINT LPAREN Expr:E1 RPAREN SemiCrazyIdea:S2 {: RESULT=new StatementPrintExpr(E1, S2); RESULT.setLine(E1left); :}
            |
            (StatementPrintExprNumber) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SemiCrazyIdea:S3 {: RESULT=new StatementPrintExprNumber(E1, N2, S3); RESULT.setLine(E1left); :}
            |
            (StatementReturnExpr) RETURN Expr:E1 SemiCrazyIdea:S2 {: RESULT=new StatementReturnExpr(E1, S2); RESULT.setLine(E1left); :}
            |
            (StatementReturn) RETURN SemiCrazyIdea:S1 {: RESULT=new StatementReturn(S1); RESULT.setLine(S1left); :}
            |
            (StatementContinue) CONTINUE SemiCrazyIdea:S1 {: RESULT=new StatementContinue(S1); RESULT.setLine(S1left); :}
            |
            (StatementBreak) BREAK SemiCrazyIdea:S1 {: RESULT=new StatementBreak(S1); RESULT.setLine(S1left); :}
            |
            (StatementBody) LBRACE StatementList:S1 RBRACE {: RESULT=new StatementBody(S1); RESULT.setLine(S1left); :}
            |
            (StatementIf) IF LPAREN PrepareCondition:P1 Condition:C2 FinalizeCondition:F3 RPAREN StatementAdr:S4 Statement:S5 OptionalElse:O6 {: RESULT=new StatementIf(P1, C2, F3, S4, S5, O6); RESULT.setLine(P1left); :}
            |
            (StatementFor) FOR ForStart:F1 LPAREN OptionalForDesignatorStatement:O2  SemiCrazyIdea:S3 OptionalForCondition:O4 SemiCrazyIdea:S5 DesignatorJumpBack:D6 OptionalForDesignatorStatement:O7 JumpToEnd:J8 RPAREN ForStatements:F9 JumpToDesignatorStatement2:J10 ForEnd:F11 ForExit:F12 {: RESULT=new StatementFor(F1, O2, S3, O4, S5, D6, O7, J8, F9, J10, F11, F12); RESULT.setLine(F1left); :}
            |
            (StatementForEach) FOREACH ForeachStart:F1 LPAREN ForeachIterator:F2 ForeachHiddenIterator:F3 ColonKeyword:C4 ForeachArrayDesignator:F5 RPAREN ForeachBegin:F6 Statement:S7 ForeachEnd:F8 ForeachExit:F9 {: RESULT=new StatementForEach(F1, F2, F3, C4, F5, F6, S7, F8, F9); RESULT.setLine(F1left); :}
            |
            error SEMI:l
            {: parser.report_error("Izvrsen oporavak do ; " + lleft, null); :} {: RESULT=new StatementDerived1(); :}
            ;

SemiCrazyIdea ::= (SemiCrazyIdea) EndExprStack:E1 SEMI {: RESULT=new SemiCrazyIdea(E1); RESULT.setLine(E1left); :};

PrepareCondition ::= (PrepareCondition) {: RESULT=new PrepareCondition(); :} /* Epsilon */;
StatementAdr ::= (StatementAdr) {: RESULT=new StatementAdr(); :} /* Epsilon */;
OptionalElse ::= (OptionalElseTrue) ElseKeyword:E1 Statement:S2 {: RESULT=new OptionalElseTrue(E1, S2); RESULT.setLine(E1left); :}
                |
                (OptionalElseFalse) {: RESULT=new OptionalElseFalse(); :} /* Epsilon */
                ;
FinalizeCondition ::= (FinalizeCondition) {: RESULT=new FinalizeCondition(); :} /* Epsilon */;
ElseKeyword ::= (ElseKeyword) ELSE {: RESULT=new ElseKeyword(); :};

ForeachStart ::= (ForeachStart) {: RESULT=new ForeachStart(); :} /* Epsilonn */;
ForeachIterator ::= (ForeachIterator) STRING:ident {: RESULT=new ForeachIterator(ident); RESULT.setLine(identleft); :};
ForeachHiddenIterator ::= (ForeachHiddenIterator) {: RESULT=new ForeachHiddenIterator(); :} /* Epsilon */;
ColonKeyword ::= (ColonKeyword) COLON {: RESULT=new ColonKeyword(); :};
ForeachArrayDesignator ::= (ForeachArrayDesignator) Designator:D1 {: RESULT=new ForeachArrayDesignator(D1); RESULT.setLine(D1left); :};
ForeachBegin ::= (ForeachBegin) {: RESULT=new ForeachBegin(); :} /* Epsilon */;
ForeachEnd ::= (ForeachEnd) {: RESULT=new ForeachEnd(); :} /* Epsilon */;
ForeachExit ::= (ForeachExit) {: RESULT=new ForeachExit(); :} /* Epsilon */;

ForStart ::= (ForStart) {: RESULT=new ForStart(); :} /* Epsilon */;
ForEnd ::= (ForEnd) {: RESULT=new ForEnd(); :} /* Epsilon */;
DesignatorJumpBack ::= (DesignatorJumpBack) {: RESULT=new DesignatorJumpBack(); :} /* Epsilon */;
JumpToEnd ::= (JumpToEnd) {: RESULT=new JumpToEnd(); :} /* Epsilon */;
JumpToDesignatorStatement2 ::= (JumpToDesignatorStatement2) {: RESULT=new JumpToDesignatorStatement2(); :} /* Epsilon */;
ForExit ::= (ForExit) {: RESULT=new ForExit(); :} /* Epsilon */;
ForRepeatCondition ::= (ForRepeatCondition) {: RESULT=new ForRepeatCondition(); :} /* Epsilon */;
ForStatements ::= (ForStatements) StatementAdr:S1 Statement:S2 {: RESULT=new ForStatements(S1, S2); RESULT.setLine(S1left); :};
OptionalForDesignatorStatement ::= (ForDesignatorStatement) DesignatorStatement:D1 {: RESULT=new ForDesignatorStatement(D1); RESULT.setLine(D1left); :} | (ForDesignatorStatementEmpty) {: RESULT=new ForDesignatorStatementEmpty(); :} /* Epsilon */;
OptionalForCondition ::= (ForCondition) ForRepeatCondition:F1 PrepareCondition:P2 Condition:C3 FinalizeCondition:F4 JumpToStatements:J5 {: RESULT=new ForCondition(F1, P2, C3, F4, J5); RESULT.setLine(F1left); :}
                        |
                         (ForConditionEmpty) ForRepeatCondition:F1 {: RESULT=new ForConditionEmpty(F1); RESULT.setLine(F1left); :}
                         |
                         (ForConditionError) error:l
                         {: parser.report_error("Error u conditionu for petlje. Oporavak do ;" + lleft, null); :} {: RESULT=new ForConditionError(); :}
                         ;

JumpToStatements ::= (JumpToStatements) {: RESULT=new JumpToStatements(); :} /* Epsilon */;

DesignatorStatement ::= (DesignatorStatementAssignOpExpr) Designator:D1 AssingOp:A2 {: RESULT=new DesignatorStatementAssignOpExpr(D1, A2); RESULT.setLine(D1left); :}
                        |
                        (DesignatorStatementIncrement) Designator:D1 INC {: RESULT=new DesignatorStatementIncrement(D1); RESULT.setLine(D1left); :}
                        |
                        (DesignatorStatementDecrement) Designator:D1 DEC {: RESULT=new DesignatorStatementDecrement(D1); RESULT.setLine(D1left); :}
                        |
                        (DesignatorStatementFunCallPars) FunctionCall:F1 {: RESULT=new DesignatorStatementFunCallPars(F1); RESULT.setLine(F1left); :}
                        ;
// EndExprStack at the end each in assignop
AssingOp ::= (AssignEqual) EQUAL Expr:E1 {: RESULT=new AssignEqual(E1); RESULT.setLine(E1left); :}
            |
            (AssignAddopRight) LoadDesignator1:L1 AddopRight:A2 Expr:E3 {: RESULT=new AssignAddopRight(L1, A2, E3); RESULT.setLine(L1left); :}
            |
            (AssignMulopRight) LoadDesignator1:L1 MulopRight:M2 Expr:E3 {: RESULT=new AssignMulopRight(L1, M2, E3); RESULT.setLine(L1left); :}
            ;

PrepareDesignatorForCombined ::= (PrepareDesignatorForCombined) Designator:D1 {: RESULT=new PrepareDesignatorForCombined(D1); RESULT.setLine(D1left); :};
LoadDesignator ::= (LoadDesignator) {: RESULT=new LoadDesignator(); :} /* Epsilonn */;
UnloadDesignator ::= (UnloadDesignator) {: RESULT=new UnloadDesignator(); :} /* Epsilonn */;
LoadDesignator1 ::= (LoadDesignator1) {: RESULT=new LoadDesignator1(); :} /* Epsilonn */;

Addop ::= (Addop_AddopLeft) AddopLeft:A1 {: RESULT=new Addop_AddopLeft(A1); RESULT.setLine(A1left); :} | (Addop_AddopRight)  AddopRight:A1 {: RESULT=new Addop_AddopRight(A1); RESULT.setLine(A1left); :};
Mulop ::= (Mulop_MulopLeft) MulopLeft:M1 {: RESULT=new Mulop_MulopLeft(M1); RESULT.setLine(M1left); :} | (Mulop_MulopRight) MulopRight:M1 {: RESULT=new Mulop_MulopRight(M1); RESULT.setLine(M1left); :} ;

AddopLeft ::= (AddopLeftPlus) PLUS {: RESULT=new AddopLeftPlus(); :} | (AddopLeftMinus) MINUS {: RESULT=new AddopLeftMinus(); :};
AddopRight ::= (AddopRightPlusEqual) PLUSEQUAL {: RESULT=new AddopRightPlusEqual(); :} | (AddopRightMinusEqual) MINUSEQUAL {: RESULT=new AddopRightMinusEqual(); :};
MulopLeft ::= (MulopLeftMul) MUL {: RESULT=new MulopLeftMul(); :} | (MulopLeftDiv) DIV {: RESULT=new MulopLeftDiv(); :} | (MulopLeftMod) MOD {: RESULT=new MulopLeftMod(); :};
MulopRight ::= (MulopRightMulEqual) MULEQUAL {: RESULT=new MulopRightMulEqual(); :} | (MulopRightDivEqual) DIVEQUAL {: RESULT=new MulopRightDivEqual(); :} | (MulopRightModEqual) MODEQUAL {: RESULT=new MulopRightModEqual(); :};

Designator ::=  (DesignatorSingle) STRING:name {: RESULT=new DesignatorSingle(name); RESULT.setLine(nameleft); :}
                |
                (DesignatorArray)  DesignatorArrayHelper:D1 LSQUARE Expr:e RSQUARE {: RESULT=new DesignatorArray(D1, e); RESULT.setLine(D1left); :}
                |
                (DesignatorMember) Designator:D1 DOT STRING:ident {: RESULT=new DesignatorMember(D1, ident); RESULT.setLine(D1left); :}
                ;
DesignatorArrayHelper::= (DesignatorArrayHelper) Designator:D1 {: RESULT=new DesignatorArrayHelper(D1); RESULT.setLine(D1left); :};
Negative ::= (NegativeTrue) MINUS {: RESULT=new NegativeTrue(); :} | (NegativeFalse) {: RESULT=new NegativeFalse(); :} /* Epsilon */;

Expr ::= (ExprTerm) Negative:N1 Term:T2 {: RESULT=new ExprTerm(N1, T2); RESULT.setLine(N1left); :}
        |
        (ExprTermAddOpTerm) Expr:E1 LoadDesignator1:L2 Addop:A3 Term:T4 {: RESULT=new ExprTermAddOpTerm(E1, L2, A3, T4); RESULT.setLine(E1left); :}
        |
        (ExprMaxArray) MAX Term:T1 {: RESULT=new ExprMaxArray(T1); RESULT.setLine(T1left); :}
        |
        (ExprGetCounter) Expr:array HASH Term:max {: RESULT=new ExprGetCounter(array, max); RESULT.setLine(arrayleft); :}
        ;



Term ::= (TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :} | (TermMulOpFactor) Term:T1 LoadDesignator1:L2 Mulop:M3 Factor:F4 {: RESULT=new TermMulOpFactor(T1, L2, M3, F4); RESULT.setLine(T1left); :};
EndExprStack ::= (EndExprStack) {: RESULT=new EndExprStack(); :} /* Epsilon */;
EndTermStack ::= (EndTermStack) {: RESULT=new EndTermStack(); :} /* Epsilon */;
Factor ::=  (FactorConst) ConstGroup:C1 {: RESULT=new FactorConst(C1); RESULT.setLine(C1left); :}
            |
            (FactorParenExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorParenExpr(E1); RESULT.setLine(E1left); :}
            |
            (FactorNewType) NEW Type:T1 {: RESULT=new FactorNewType(T1); RESULT.setLine(T1left); :}
            |
            (FactorNewTypeArray) NEW Type:T1 LSQUARE Expr:E2 RSQUARE {: RESULT=new FactorNewTypeArray(T1, E2); RESULT.setLine(T1left); :}
            |
            (FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
            |
            (FactorFunCallPars) FunctionCall:F1 {: RESULT=new FactorFunCallPars(F1); RESULT.setLine(F1left); :}
            ;

FunctionCall ::= (FunCall) Designator:D1 LPAREN ActParsStart:A2 ActPars:A3 RPAREN {: RESULT=new FunCall(D1, A2, A3); RESULT.setLine(D1left); :};

ActPars ::= (ActParsListing) ActParsList:A1 {: RESULT=new ActParsListing(A1); RESULT.setLine(A1left); :} | (ActParsEmpty) {: RESULT=new ActParsEmpty(); :} /* Epsilon */;
ActParsList ::= (ParList) ActParsList:A1 COMMA ActPar:A2 {: RESULT=new ParList(A1, A2); RESULT.setLine(A1left); :} | (ParSingle) ActPar:A1 {: RESULT=new ParSingle(A1); RESULT.setLine(A1left); :};
ActPar ::= (ActPar) Expr:E1 {: RESULT=new ActPar(E1); RESULT.setLine(E1left); :};
ActParsStart ::= (ActParsStart) {: RESULT=new ActParsStart(); :} /* Epsilon */;

Condition ::= (ConditionList) Condition:C1 OrKeyword:O2 ConditionTerm:C3 {: RESULT=new ConditionList(C1, O2, C3); RESULT.setLine(C1left); :} | (ConditionSingle) ConditionTerm:C1 {: RESULT=new ConditionSingle(C1); RESULT.setLine(C1left); :};
OrKeyword ::= (OrKeyword) OR {: RESULT=new OrKeyword(); :};
ConditionTerm ::= (ConditionTermList) ConditionTerm:C1 AndKeyword:A2 ConditionFact:C3 {: RESULT=new ConditionTermList(C1, A2, C3); RESULT.setLine(C1left); :} | (ConditionTermSingle) ConditionFact:C1 {: RESULT=new ConditionTermSingle(C1); RESULT.setLine(C1left); :};
AndKeyword ::= (AndKeyword) AND {: RESULT=new AndKeyword(); :};
ConditionFact ::= (ConditionFactExpr) Expr:E1 {: RESULT=new ConditionFactExpr(E1); RESULT.setLine(E1left); :} | (ConditionFactExprOpExpr) Expr:firstExpr Relop:R1 Expr:secondExpr {: RESULT=new ConditionFactExprOpExpr(firstExpr, R1, secondExpr); RESULT.setLine(firstExprleft); :};
Relop ::= (RelOpEq) EQ {: RESULT=new RelOpEq(); :} | (RelOpNeq) NEQ {: RESULT=new RelOpNeq(); :} | (RelOpGt) GT {: RESULT=new RelOpGt(); :} | (RelOpGte) GTE {: RESULT=new RelOpGte(); :} | (RelOpLt) LT {: RESULT=new RelOpLt(); :} | (RelOpLte) LTE {: RESULT=new RelOpLte(); :};



